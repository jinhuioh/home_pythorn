#힌트! 접근방법
# !좌표에서 이동하면서 지나간 거리 채크하는 문제
# x,y좌표 방문했는지도 채크해야하지만
# 방향성도 채크해야한다@@@!!
# ex) (0,1) -> (1,1), (1,0)->(1,1) 둘다 (1,1)로 가므로 중복되지만 어디서 이동하는지 값이 다르기 때문에 중복으로 채크하면 안된다!!!!
# (x,y,nx,ny)로 튜플로 묶어서 리스트에 담에
# (x,y,nx,ny)의 값이 있으면 pass 아니면 카운트하여 풀면 된다. 
# 이 경우 (0,0) ->(0,1) 은 (0,1) -> (0,0)과 같으므로
# 중복처리를 위해 (x,y,nx,ny), (nx,ny,x,y) 둘 다 리스트에 담아주어 중복채크를 진행한다.










#게임 캐릭터를 4가지 명령어를 통해 움직이려 합니다. 명령어는 다음과 같습니다.
#
# U: 위쪽으로 한 칸 가기
#
# D: 아래쪽으로 한 칸 가기
#
# R: 오른쪽으로 한 칸 가기
#
# L: 왼쪽으로 한 칸 가기
#
# 캐릭터는 좌표평면의 (0, 0) 위치에서 시작합니다.
# 좌표평면의 경계는 왼쪽 위(-5, 5), 왼쪽 아래(-5, -5), 오른쪽 위(5, 5), 오른쪽 아래(5, -5)로 이루어져 있습니다.
# 이때, 우리는 게임 캐릭터가 지나간 길 중 캐릭터가 처음 걸어본 길의 길이를 구하려고 합니다.
# 예를 들어, "ULURRDLLU"로 명령했다면,
# 위의 예시에서 게임 캐릭터가 움직인 길이는 9이지만, 캐릭터가 처음 걸어본 길의 길이는 7이 됩니다.
# (8, 9번 명령어에서 움직인 길은 2, 3번 명령어에서 이미 거쳐 간 길입니다)
#
# 단, 좌표평면의 경계를 넘어가는 명령어는 무시합니다.

# 2시55

#0으로 된 행렬 리스트를 하나 만들어서 방문했으면 1로 바꿈 그리고 만약 이미 1이라면 pass

# 상하좌우xy리스트를 만들어주자.

#for문을 돌려 주어진 dirs만큼 이동시키면서 행렬리스트의 0의 값을 1로 바꿔줌

#행렬리스트sum=answer을 리턴해줌


##!!!!!!! 방문한 위치 채크뿐만 아니라 방향성까지 판단해야 하는 문제이므로
# 튜플로(x위치,y위치, nx = x의 이동 위치,ny = y의 이동 위치)까지 채크해주어야 한다. !!!!!!!!

# path = [0] * 10
# graph = []
# for i in range(10):
#     graph.append(path)
# graph[0][0] = 1
# print(graph)




from collections import deque

# dirs="ULURRDLLU"
# dirs = "UDDDDDDUURRRLRLR"
# dirs = "LULLLLLLU"
dirs = "ULURRDLLU"
def solution(dirs):
    queue = deque()
    move = ['U', 'D', 'L', 'R']  # i값을 증가시키면서 이동시키기 위해 리스트에 담음
    dx = [0, 0, -1, 1]  # 좌우
    dy = [1, -1, 0, 0]  # 상하

    answer = 0#초기값 이동거리
    x,y = 0,0#시작 위치
    for one in dirs:
        for i in range(4):#상하좌우탐색
            if move[i] == one:
                # 좌표평면의 경계를 넘어가는 명령어 무시
                if x + dx[i] > 5 or x + dx[i] < -5 or y + dy[i] > 5 or y + dy[i] < -5:
                    continue
                # 거리 이동시키기
                nx = x + dx[i]
                ny = y + dy[i]
                if (x,y,nx,ny) in queue:
                    pass
                else:
                    queue.appendleft((x,y,nx,ny))#(0,0)에서 (0,1)로 가는경우는 아래
                    queue.append((nx,ny,x,y))#(0,1)에서 (0,0)으로 가는 경우와 같이 때문에 같이 append 해준다.
                    answer += 1
                # x,y를 이동값으로 바꾸어주기
                x = nx
                y = ny
    return answer

print(solution(dirs))